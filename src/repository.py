import twisted.enterprise.adbapi
import twisted.internet.defer
import ipaddr
import zope.interface
import interfaces
import twisted.python.failure
import address


class BaseRepository(object):
    """
    base class for db interface
    """

    dbpool = None

    def __init__(self, dbpool):
        self.dbpool = dbpool

class NmapUseableAddressRepository(BaseRepository):

    zope.interface.implements(interfaces.IUseableReference)

    def isUseable(self, address):
        """
        return Deferred witch True, if address can be used to scan
        """
        def c(result):
            return len(result) < 1
        d = self.dbpool.runQuery(
                "select \
                    id \
                from hosts \
                where address = %s",
                (unicode(address),))
        d.addCallback(c)
        return d

class WebCrawlerUrlUseableRepository(BaseRepository):

    zope.interface.implements(interfaces.IUseableReference)

    def isUseable(self, url):
        def c(result, deferred):
            if len(result) > 0:
                twisted.internet.defer.succeed(result[0][0]).addCallback(
                    _DeferredWebCrawlerUseableReference(self, deferred))
            else:
                deferred.callback(True)
        d = twisted.internet.defer.Deferred()
        self.dbpool.runQuery(
            "select \
                id \
            from url_view \
            where url ilike %s",
            (unicode(url),)).addCallback(c, d)
        return d

    def hasPageRecord(self, urlId):
        def c(result):
            return len(result) > 0
        d = self.dbpool.runQuery(
            "select \
                * \
            from www_page_located_at_urls \
            where url_id = %s",
            (urlId,))
        d.addCallback(c)
        return d


class HostRepository(BaseRepository):
    """
    save information about servers
    """

    def saveHost(self, hostId, address, state):
        """
        save host into database
        if host id already exists, its record will be updated,
        otherwise new one will be created
        """
        d = twisted.internet.defer.Deferred()
        def c(idExists, hostId, address, state, deferred):
            def c2(result, deferred):
                deferred.callback(result)
            if idExists:
                self.dbpool.runOperation(
                    "update hosts \
                        set address = %s, \
                        addrtype = %s, \
                        state = %s, \
                        time = now() \
                    where id = %s",
                    (unicode(address),
                        address.version,
                        _getHostStateChar(state),
                        hostId)).addCallback(c2, deferred)
            else:
                self.dbpool.runOperation(
                    "insert \
                        into hosts( \
                            id, \
                            address, \
                            addrtype, \
                            state) \
                        values (%s, %s, %s, %s)",
                    (hostId,
                        unicode(address),
                        address.version,
                        _getHostStateChar(state))).addCallback(c2, deferred)
        self.hostIdExists(hostId).addCallback(c, hostId, address, state, d)
        return d

    def generateHostId(self):
        """
        return deferred with number indicating host id
        """
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery("select nextval('seq_host_id')")
        d.addCallback(c)
        return d

    def getHostId(self, address):
        """
        find host in the database using an address and return its id
        if host is'nt present in the database, return id generated by the
        sequence
        """
        def c(result, deferred):
            if len(result) > 0:
                deferred.callback(result[0][0])
            else:
                def c2(hostId, deferred):
                    deferred.callback(hostId)
                self.generateHostId().addCallback(c2, deferred)
        d = twisted.internet.defer.Deferred()
        self.dbpool.runQuery(
            "select \
                id \
            from hosts \
            where address like %s",
            (unicode(address),)).addCallback(c, d)
        return d

    def hostIdExists(self, hostId):
        def c(result):
            return len(result) > 0
        d = self.dbpool.runQuery(
            "select \
                id \
            from hosts \
            where id = %s",
            (hostId,))
        d.addCallback(c)
        return d

    def getHost(self, address):
        return self.dbpool.runQuery(
            "select \
                id, \
                address, \
                addrtype, \
                state, \
                time \
            from hosts \
            where address like %s",
            (unicode(address),))

    def getNonScannedHosts(self):
        """
        return list of addresses which are marked as non-scanned
        """
        def c(result):
            l = []
            for i in result:
                l.append(address.Address(i['address']))
            return l
        d = self.dbpool.runQuery(
            "select \
                address \
            from hosts \
            where state = 'N'")
        d.addCallback(c)
        return d

class PortRepository(BaseRepository):
    """
    save information about scanned ports
    """

    def saveScannedPort(self, hostId, port, protocol, state, reason):
        return self.dbpool.runOperation(
            "insert \
                into ports(\
                    host_id, \
                    port, \
                    protocol, \
                    state, \
                    reason) \
                values (%s, %s, %s, %s, %s)",
            (hostId,
                port,
                protocol,
                _getPortStateChar(state),
                reason))

    def saveScriptResult(self, scriptResultId, hostId, port, name, output):
        return self.dbpool.runOperation(
            "insert \
                into script_results(\
                id, \
                host_id, \
                port, \
                name, \
                output) \
            values (%s, %s, %s, %s, %s)",
            (scriptResultId,
                hostId,
                port,
                name,
                output))

    def saveScriptResultElement(self, scriptResultId, key, text):
        return self.dbpool.runOperation(
            "insert \
                into script_result_elements(\
                    script_result_id, \
                    key, \
                    text) \
                values (%s, %s, %s)",
            (scriptResultId, key, text))


    def generateScriptResultId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery("select nextval('seq_script_result_id')")
        d.addCallback(c)
        return d

class HostnameRepository(BaseRepository):
    """
    save hostnames
    """

    def saveHostname(self, hostId, name, hostnameType):
        return self.dbpool.runOperation(
            "insert \
                into hostnames(\
                    host_id, \
                    name, \
                    type) \
                values (%s, %s, %s)",
            (hostId, name, hostnameType))

class ServiceRepository(BaseRepository):
    """
    save services information
    """

    cpeRepository = None

    def __init__(self, dbpool, cpeRepository):
        BaseRepository.__init__(self, dbpool)
        self.cpeRepository = cpeRepository

    def saveService(self, hostId, port, name, method, conf, product, version,
            hostname, ostype, extrainfo, tunnel, proto, rpcnum, lowver,
            highver, devicetype, servicefp):
        m = None
        if method == 'probed':
            m = 'P'
        elif method == 'table':
            m = 'T'
        else:
            m = 'E'
        t = None
        if tunnel is None:
            t = None
        elif tunnel == "ssh":
            t = "S"
        else:
            t = "E"
        p = None
        if proto is None:
            p = None
        elif proto == 'rpc':
            p = "R"
        else:
            p = "E"
        return self.dbpool.runOperation(
            "insert \
                into services(\
                    host_id, \
                    port, \
                    name, \
                    product, \
                    method, \
                    version, \
                    extrainfo, \
                    ostype, \
                    conf, \
                    hostname, \
                    tunnel, \
                    proto, \
                    rpcnum, \
                    lowver, \
                    highver, \
                    devicetype, \
                    servicefp) \
                values (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)",
            (hostId,
                port,
                name,
                product,
                m,
                version,
                extrainfo,
                ostype,
                conf,
                hostname,
                t,
                p,
                rpcnum,
                lowver,
                highver,
                devicetype,
                servicefp))

    def saveCpe(self, hostId, port, cpe):
        d = twisted.internet.defer.Deferred()
        self.cpeRepository.generateCpeId().addCallback(
            _DeferredCpeService(
                d,
                hostId,
                port,
                cpe,
                self,
                self.cpeRepository))
        return d

    def associateCpe(self, hostId, port, cpeId):
        return self.dbpool.runOperation(
            'insert \
                into service_cpe(\
                    host_id, \
                    port, \
                    cpe_id) \
                values (%s, %s, %s)',
            (hostId, port, cpeId))

class CpeRepository(BaseRepository):
    """
    save cpe
    """

    def saveCpe(self, cpeId, cpe):
        return self.dbpool.runOperation(
            "insert \
                into cpe(\
                    id, \
                    cpe) \
                values (%s, %s)",
            (cpeId, cpe))

    def generateCpeId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery("select nextval('seq_cpe_id')")
        d.addCallback(c)
        return d

class OsRepository(BaseRepository):
    """
    """

    cpeRepository = None

    def __init__(self, dbpool, cpeRepository):
        BaseRepository.__init__(self, dbpool)
        self.cpeRepository = cpeRepository

    def createOsId(self, hostId):
        d = twisted.internet.defer.Deferred()
        def c(result):
            return result[0][0]
        d2 = self.dbpool.runQuery(
            "select nextval('seq_os_id')")
        d2.addCallback(c)
        d2.addCallback(_DeferredOsId(
            d,
            hostId,
            self))
        return d

    def saveUsedPort(self, osId, state, proto, port):
        return self.dbpool.runOperation(
            "insert \
                into os_used_ports(\
                    os_id, \
                    state, \
                    proto, \
                    portid) \
                values (%s, %s, %s, %s)",
            (osId,
                _getPortStateChar(state),
                proto,
                port))

    def generateOsmatchId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery(
            "select nextval('seq_osmatch_id')")
        d.addCallback(c)
        return d

    def generateOsclassId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery(
            "select nextval('seq_osclass_id')")
        d.addCallback(c)
        return d

    def saveOsmatch(self, osmatchId, osId, name, accuracy, line):
        return self.dbpool.runOperation(
            "insert \
                into os_osmatch(\
                    id, \
                    os_id, \
                    name, \
                    accuracy, \
                    line) \
                values (%s, %s, %s, %s, %s)",
            (osmatchId, osId, name, accuracy, line))

    def saveOsclass(self, osclassId, osmatchId, vendor, accuracy, osfamily, osgen, ostype):
        return self.dbpool.runOperation(
            "insert into os_osclass(id, osmatch_id, vendor, accuracy, osfamily, osgen, type) values (%s, %s, %s, %s, %s, %s, %s)",
            (osclassId,
                osmatchId,
                vendor,
                accuracy,
                osfamily,
                osgen,
                ostype))

    def saveCpe(self, osclassId, cpe):
        d = twisted.internet.defer.Deferred()
        def c(result):
            return result[0][0]
        d2 = self.dbpool.runQuery(
            "select nextval('seq_cpe_id')").addCallback(c)
        d2.addCallback(
            _DeferredOsCpe(
                d,
                osclassId,
                cpe,
                self.cpeRepository,
                self))
        return d

    def associateCpe(self, osclassId, cpeId):
        return self.dbpool.runOperation(
            "insert into os_osclass_cpe(osclass_id, cpe_id) values (%s, %s)",
            (osclassId, cpeId))

class UrlRepository(BaseRepository):

    def generateUrlId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery(
            "select nextval('seq_url_id')")
        d.addCallback(c)
        return d

    def saveUrl(self, urlId, url, redirectUrlId):
        d = twisted.internet.defer.Deferred()
        def c2(result, deferred):
            deferred.callback(None)
        def c(result, urlId, query, deferred):
            if query:
                order = 0
                deferreds = []
                for name, value in query.params.allitems():
                    deferreds.append(
                        self.saveUrlQuery(urlId, order, name, value))
                    order += 1
                twisted.internet.defer.DeferredList(deferreds).addCallback(
                    c2,
                    deferred)
            else:
                deferred.callback(None)
        self.dbpool.runOperation(
            "insert \
                into urls(\
                    id, \
                    scheme, \
                    username, \
                    password, \
                    location, \
                    port, \
                    path, \
                    redirect_url_id) \
                values (%s, %s, %s, %s, %s, %s, %s, %s)",
            (urlId,
                url.scheme,
                url.username,
                url.password,
                url.host,
                None if url.hasStandardPort() else url.port,
                unicode(url.path),
                redirectUrlId)).addCallback(
                    c,
                    urlId,
                    url.query,
                    d)
        return d

    def saveUrlQuery(self, urlId, order, key, value):
        return self.dbpool.runOperation(
            "insert into url_queries(url_id, order_num, key, value) values (%s, %s, %s, %s)",
            (urlId, order, key, value))

    def associateUrlWithHost(self, urlId, hostId):
        return self.dbpool.runOperation(
            "insert into urls_resolved_to_hosts(url_id, host_id) values (%s, %s)",
            (urlId, hostId))

    def getUrl(self, url):
        return self.dbpool.runQuery(
            "select id, url from url_view where url ilike %s",
            (unicode(url),))

    def updateRedirectUrlId(self, urlId, redirectUrlId):
        return self.dbpool.runOperation(
            "update urls set redirect_url_id = %s where id = %s",
            (redirectUrlId, urlId))

class WWWPageRepository(BaseRepository):

    urlRepository = None

    def __init__(self, dbpool, urlRepository):
        BaseRepository.__init__(self, dbpool)
        self.urlRepository = urlRepository

    def generatePageId(self):
        def c(result):
            return result[0][0]
        d = self.dbpool.runQuery(
            "select nextval('seq_page_id')")
        d.addCallback(c)
        return d

    def savePage(self, pageId, headers, title):
        """
        save page into database
        """
        d = twisted.internet.defer.Deferred()
        def c(result, pageId, headers, deferred):
            """
            save all headers
            """
            deferreds = []
            if len(headers) > 0:
                for header in headers:
                    deferreds.append(
                        self.savePageHeader(pageId, header.name, header.value))
                dl = twisted.internet.defer.DeferredList(deferreds)
                dl.addCallback(c2, deferred)
            else:
                deferred.callback(result)
        def c2(result, deferred):
            deferred.callback(None)
        self.dbpool.runOperation(
            "insert into www_pages(id, title) values (%s, %s)",
            (pageId, title)).addCallback(c, pageId, headers, d)
        return d

    def savePageHeader(self, pageId, name, value):
        return self.dbpool.runOperation(
            "insert into http_headers(page_id, name, value) values (%s, %s, %s)",
            (pageId, name, value))

    def savePageAndUrlFetchInfo(self, pageId, urlId, version, status, message):
        """
        associate single url with sinle page, communication wit server has
        been succeed
        """
        d = twisted.internet.defer.Deferred()
        def c(result, pageId, urlId, version, status, message, deferred):
            self.dbpool.runOperation(
                "insert into www_page_fetch_info(page_id, url_id, version, status_code, message) values (%s, %s, %s, %s, %s)",
                (pageId,
                    urlId,
                    version,
                    status,
                    message)).addCallback(c2, deferred)
        def c2(result, deferred):
            deferred.callback(None)
        self.associatePageAndUrl(
            pageId,
            urlId,
            True).addCallback(c,
                                pageId,
                                urlId,
                                version,
                                status,
                                message,
                                d)
        return d

    def savePageAndUrlErrorExtras(self, pageId, urlId, message):
        """
        associate singleUrl with single page, communication with server failed
        """
        d = twisted.internet.defer.Deferred()
        def c(result, pageId, urlId, message, deferred):
            self.dbpool.runOperation(
                "insert into www_page_error_extras(page_id, url_id, error_message) values (%s, %s, %s)",
                (pageId,
                    urlId,
                    message)).addCallback(c2, deferred)
        def c2(result, deferred):
            deferred.callback(None)
        self.associatePageAndUrl(
            pageId,
            urlId,
            False).addCallback(c,
                                pageId,
                                urlId,
                                message,
                                d)
        return d

    def associatePageAndUrl(self, pageId, urlId, fetched):
        return self.dbpool.runOperation(
            "insert into www_page_located_at_urls(page_id, url_id, fetched) values (%s, %s, %s)",
            (pageId,
                urlId,
                fetched))

    def saveHttpHeader(self, pageId, name, value):
        return self.dbpool.runOperation(
            "insert into http_headers(page_id, name, value) values (%s, %s, %s)",
            (pageId, name, value))

    def isPageFetched(self, url):
        """
        returns deferred with true, if page is already fetched,
        false otherwise
        """
        d = twisted.internet.defer.Deferred()
        def c(result, deferred):
            if len(result) > 0:
                def c2(result, deferred):
                    deferred.callback(len(result) > 0)
                self.dbpool.runQuery(
                    "select page_id, url_id from www_page_located_at_urls where url_id = %s",
                    (result[0][0],)).addCallback(c2, deferred)
            else:
                deferred.callback(False)
        self.urlRepository.getUrl(url).addCallback(c, d)
        return d

    def getPageId(self, url):
        """
        get id of page, which is associated with given url
        fire errback with KeyError if url isn't associated with any page
        """
        d = twisted.internet.defer.Deferred()
        def c(result, url, deferred):
            if len(result) > 0:
                def c2(result, url, deferred):
                    if len(result) > 0:
                        deferred.callback(result[0][0])
                    else:
                        deferred.errback(
                            twisted.python.failure.Failure(
                                KeyError("url isn't associated with any page: " + unicode(url))))
                self.dbpool.runQuery(
                    "select page_id from www_page_located_at_urls where url_id = %s",
                    (result[0][0],)).addCallback(c2, url, deferred)
            else:
                deferred.errback(
                    twisted.python.failure.Failure(
                        KeyError("url not found: " + unicode(url))))
        self.urlRepository.getUrl(url).addCallback(c, url, d)
        return d

    def saveAdditionalInfo(self, pageId, infoClass, message):
        return self.dbpool.runOperation(
            "insert into www_page_additional_info(page_id, class, message) values (%s, %s, %s)",
            (pageId,
                infoClass,
                message))

class _DeferredUrlQueries(object):

    repository = None
    urlId = None
    url = None
    deferred = None
    savedQueryRemaining = None

    def __init__(self, repository, urlId,  url, deferred):
        self.repository = repository
        self.urlId = urlId
        self.url = url
        self.deferred = deferred
        self.savedQueryRemaining = len(url.getQueries())

    def __call__(self, result):
        if len(self.url.getQueries()) > 0:
            for query in self.url.getQueries():
                self.repository.saveUrlQuery(
                    self.urlId,
                    query[0],
                    query[1]).addCallback(
                        self.querySaved)
        else:
            self.deferred.callback(result)

    def querySaved(self, result):
        self.savedQueryRemaining -= 1
        if not self.savedQueryRemaining > 0:
            self.deferred.callback(None)

class _DeferredOsCpe(object):

    deferred = None
    osclassId = None
    cpe = None
    cpeRepository = None
    osRepository = None

    def __init__(self, deferred, osclassId, cpe, cpeRepository, osRepository):
        self.deferred = deferred
        self.osclassId = osclassId
        self.cpe = cpe
        self.cpeRepository = cpeRepository
        self.osRepository = osRepository

    def __call__(self, cpeId):
        self.cpeRepository.saveCpe(
            cpeId,
            self.cpe).addCallback(
                _DeferredOsCpeAssociation(
                    self.deferred,
                    self.osclassId,
                    cpeId,
                    self.osRepository))

class _DeferredOsCpeAssociation(object):

    deferred = None
    osclassId = None
    cpeId = None
    osRepository = None

    def __init__(self, deferred, osclassId, cpeId, osRepository):
        self.deferred = deferred
        self.osclassId = osclassId
        self.cpeId = cpeId
        self.osRepository = osRepository

    def __call__(self, reason):
        self.osRepository.associateCpe(
            self.osclassId,
            self.cpeId).addCallback(
                lambda x : self.deferred.callback(x))

class _DeferredOsId(object):

    deferred = None
    hostId = None
    osRepository = None

    def __init__(self, deferred, hostId, osRepository):
        self.deferred = deferred
        self.hostId = hostId
        self.osRepository = osRepository

    def __call__(self, osId):
        self.osRepository.dbpool.runOperation(
            "insert into os(id, host_id) values (%s, %s)",
            (osId, self.hostId)).addCallback(
                _DeferredOsIdSave(
                    self.deferred,
                    osId))

class _DeferredOsIdSave(object):

    deferred = None
    osId = None

    def __init__(self, deferred, osId):
        self.deferred = deferred
        self.osId = osId

    def __call__(self, reason):
        self.deferred.callback(self.osId)

class _DeferredCpeService(object):

    deferred = None
    hostId = None
    port = None
    cpe = None
    hostRepository = None
    cpeRepository = None

    def __init__(self, deferred, hostId, port, cpe, hostRepository, cpeRepository):
        self.deferred = deferred
        self.hostId = hostId
        self.port = port
        self.cpe = cpe
        self.hostRepository = hostRepository
        self.cpeRepository = cpeRepository

    def __call__(self, cpeId):
       self.cpeRepository.saveCpe(cpeId, self.cpe).addCallback(
            _DeferredCpeServiceAssociation(
                self.deferred,
                self.hostId,
                self.port,
                cpeId,
                self.hostRepository))

class _DeferredCpeServiceAssociation(object):

    deferred = None
    hostId = None
    port = None
    cpeId = None
    hostRepository = None

    def __init__(self, deferred, hostId, port, cpeId, hostRepository):
        self.deferred = deferred
        self.hostId = hostId
        self.port = port
        self.cpeId = cpeId
        self.hostRepository = hostRepository

    def __call__(self, reason):
        def c(r):
            self.deferred.callback(r)
        self.hostRepository.associateCpe(self.hostId, self.port, self.cpeId).addCallback(c)

class _DeferredWebCrawlerUseableReference(object):

    repository = None
    deferred = None

    def __init__(self, repository, deferred):
        self.repository = repository
        self.deferred = deferred

    def __call__(self, urlId):
        def c(result):
            self.deferred.callback(not result)
        self.repository.hasPageRecord(urlId).addCallback(c)

def _getPortStateChar(state):
    if state == 'open':
        return 'O'
    elif state == 'closed':
        return 'C'
    elif state == 'filtered':
        return 'F'
    else:
        return 'E'                  # error

def _getHostStateChar(state):
    state = state.lower()
    if state == 'up':
        return 'U'
    elif state == 'down':
        return 'D'
    elif state == 'not-scanned':
        return 'N'
    else:
        return 'E'                  # error
